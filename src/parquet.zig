// Generated by thrift-zig-codegen
const std = @import("std");
const TCompactProtocol = @import("TCompactProtocol.zig");
const Writer = TCompactProtocol.Writer;
const Reader = TCompactProtocol.Reader;
const TType = TCompactProtocol.TType;
const FieldMeta = TCompactProtocol.FieldMeta;
const WriterError = Writer.WriterError;
const CompactProtocolError = Reader.CompactProtocolError || error{NotImplemented};
const ThriftError = Reader.ThriftError;
const Meta = @import("Meta.zig");

fn use_arg(t: anytype) void {
    _ = t;
}

fn readFieldOrStop(r: *Reader) CompactProtocolError!?FieldMeta {
    const field = try r.readFieldBegin();
    if (field.tp == .STOP) return null;
    return field;
}

/// Wraps struct/union .read and returns 'null' on ThriftError
fn readCatchThrift(T: type, r: *Reader, alloc: std.mem.Allocator) CompactProtocolError!?T {
    if (T.read(r, alloc)) |value| {
        return value;
    } else |err| switch (err) {
        ThriftError.CantParseUnion, ThriftError.RequiredFieldMissing => {
            return null;
        },
        else => |err2| return err2,
    }
}

pub const Type = enum(i32) {
    BOOLEAN = 0,
    INT32 = 1,
    INT64 = 2,
    INT96 = 3,
    FLOAT = 4,
    DOUBLE = 5,
    BYTE_ARRAY = 6,
    FIXED_LEN_BYTE_ARRAY = 7,
    _,
};

pub const ConvertedType = enum(i32) {
    UTF8 = 0,
    MAP = 1,
    MAP_KEY_VALUE = 2,
    LIST = 3,
    ENUM = 4,
    DECIMAL = 5,
    DATE = 6,
    TIME_MILLIS = 7,
    TIME_MICROS = 8,
    TIMESTAMP_MILLIS = 9,
    TIMESTAMP_MICROS = 10,
    UINT_8 = 11,
    UINT_16 = 12,
    UINT_32 = 13,
    UINT_64 = 14,
    INT_8 = 15,
    INT_16 = 16,
    INT_32 = 17,
    INT_64 = 18,
    JSON = 19,
    BSON = 20,
    INTERVAL = 21,
    _,
};

pub const FieldRepetitionType = enum(i32) {
    REQUIRED = 0,
    OPTIONAL = 1,
    REPEATED = 2,
    _,
};

pub const SizeStatistics = struct {
    unencoded_byte_array_data_bytes: ?i64,
    repetition_level_histogram: ?std.ArrayList(i64),
    definition_level_histogram: ?std.ArrayList(i64),

    pub const FieldTag = enum(i16) {
        unencoded_byte_array_data_bytes = 1,
        repetition_level_histogram = 2,
        definition_level_histogram = 3,
    };
};

pub const BoundingBox = struct {
    xmin: f64,
    xmax: f64,
    ymin: f64,
    ymax: f64,
    zmin: ?f64,
    zmax: ?f64,
    mmin: ?f64,
    mmax: ?f64,

    pub const FieldTag = enum(i16) {
        xmin = 1,
        xmax = 2,
        ymin = 3,
        ymax = 4,
        zmin = 5,
        zmax = 6,
        mmin = 7,
        mmax = 8,
    };
};

pub const GeospatialStatistics = struct {
    bbox: ?BoundingBox,
    geospatial_types: ?std.ArrayList(i32),

    pub const FieldTag = enum(i16) {
        bbox = 1,
        geospatial_types = 2,
    };
};

pub const Statistics = struct {
    max: ?[]const u8,
    min: ?[]const u8,
    null_count: ?i64,
    distinct_count: ?i64,
    max_value: ?[]const u8,
    min_value: ?[]const u8,
    is_max_value_exact: ?bool,
    is_min_value_exact: ?bool,

    pub const FieldTag = enum(i16) {
        max = 1,
        min = 2,
        null_count = 3,
        distinct_count = 4,
        max_value = 5,
        min_value = 6,
        is_max_value_exact = 7,
        is_min_value_exact = 8,
    };
};

pub const StringType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const UUIDType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const MapType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const ListType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const EnumType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const DateType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const Float16Type = struct {
    pub const FieldTag = enum(i16) {};
};

pub const NullType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const DecimalType = struct {
    scale: i32,
    precision: i32,

    pub const FieldTag = enum(i16) {
        scale = 1,
        precision = 2,
    };
};

pub const MilliSeconds = struct {
    pub const FieldTag = enum(i16) {};
};

pub const MicroSeconds = struct {
    pub const FieldTag = enum(i16) {};
};

pub const NanoSeconds = struct {
    pub const FieldTag = enum(i16) {};
};

pub const TimeUnit = union(enum) {
    MILLIS: MilliSeconds,
    MICROS: MicroSeconds,
    NANOS: NanoSeconds,

    pub const FieldTag = enum(i16) {
        MILLIS = 1,
        MICROS = 2,
        NANOS = 3,
    };
};

pub const TimestampType = struct {
    isAdjustedToUTC: bool,
    unit: TimeUnit,

    pub const FieldTag = enum(i16) {
        isAdjustedToUTC = 1,
        unit = 2,
    };
};

pub const TimeType = struct {
    isAdjustedToUTC: bool,
    unit: TimeUnit,

    pub const FieldTag = enum(i16) {
        isAdjustedToUTC = 1,
        unit = 2,
    };
};

pub const IntType = struct {
    bitWidth: i8,
    isSigned: bool,

    pub const FieldTag = enum(i16) {
        bitWidth = 1,
        isSigned = 2,
    };
};

pub const JsonType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const BsonType = struct {
    pub const FieldTag = enum(i16) {};
};

pub const VariantType = struct {
    specification_version: ?i8,

    pub const FieldTag = enum(i16) {
        specification_version = 1,
    };
};

pub const EdgeInterpolationAlgorithm = enum(i32) {
    SPHERICAL = 0,
    VINCENTY = 1,
    THOMAS = 2,
    ANDOYER = 3,
    KARNEY = 4,
    _,
};

pub const GeometryType = struct {
    crs: ?[]const u8,

    pub const FieldTag = enum(i16) {
        crs = 1,
    };
};

pub const GeographyType = struct {
    crs: ?[]const u8,
    algorithm: ?EdgeInterpolationAlgorithm,

    pub const FieldTag = enum(i16) {
        crs = 1,
        algorithm = 2,
    };
};

pub const LogicalType = union(enum) {
    STRING: StringType,
    MAP: MapType,
    LIST: ListType,
    ENUM: EnumType,
    DECIMAL: DecimalType,
    DATE: DateType,
    TIME: TimeType,
    TIMESTAMP: TimestampType,
    INTEGER: IntType,
    UNKNOWN: NullType,
    JSON: JsonType,
    BSON: BsonType,
    UUID: UUIDType,
    FLOAT16: Float16Type,
    VARIANT: VariantType,
    GEOMETRY: GeometryType,
    GEOGRAPHY: GeographyType,

    pub const FieldTag = enum(i16) {
        STRING = 1,
        MAP = 2,
        LIST = 3,
        ENUM = 4,
        DECIMAL = 5,
        DATE = 6,
        TIME = 7,
        TIMESTAMP = 8,
        INTEGER = 10,
        UNKNOWN = 11,
        JSON = 12,
        BSON = 13,
        UUID = 14,
        FLOAT16 = 15,
        VARIANT = 16,
        GEOMETRY = 17,
        GEOGRAPHY = 18,
    };
};

pub const SchemaElement = struct {
    type: ?Type,
    type_length: ?i32,
    repetition_type: ?FieldRepetitionType,
    name: []const u8,
    num_children: ?i32,
    converted_type: ?ConvertedType,
    scale: ?i32,
    precision: ?i32,
    field_id: ?i32,
    logicalType: ?LogicalType,

    pub const FieldTag = enum(i16) {
        type = 1,
        type_length = 2,
        repetition_type = 3,
        name = 4,
        num_children = 5,
        converted_type = 6,
        scale = 7,
        precision = 8,
        field_id = 9,
        logicalType = 10,
    };
};

pub const Encoding = enum(i32) {
    PLAIN = 0,
    PLAIN_DICTIONARY = 2,
    RLE = 3,
    BIT_PACKED = 4,
    DELTA_BINARY_PACKED = 5,
    DELTA_LENGTH_BYTE_ARRAY = 6,
    DELTA_BYTE_ARRAY = 7,
    RLE_DICTIONARY = 8,
    BYTE_STREAM_SPLIT = 9,
    _,
};

pub const CompressionCodec = enum(i32) {
    UNCOMPRESSED = 0,
    SNAPPY = 1,
    GZIP = 2,
    LZO = 3,
    BROTLI = 4,
    LZ4 = 5,
    ZSTD = 6,
    LZ4_RAW = 7,
    _,
};

pub const PageType = enum(i32) {
    DATA_PAGE = 0,
    INDEX_PAGE = 1,
    DICTIONARY_PAGE = 2,
    DATA_PAGE_V2 = 3,
    _,
};

pub const BoundaryOrder = enum(i32) {
    UNORDERED = 0,
    ASCENDING = 1,
    DESCENDING = 2,
    _,
};

pub const DataPageHeader = struct {
    num_values: i32,
    encoding: Encoding,
    definition_level_encoding: Encoding,
    repetition_level_encoding: Encoding,
    statistics: ?Statistics,

    pub const FieldTag = enum(i16) {
        num_values = 1,
        encoding = 2,
        definition_level_encoding = 3,
        repetition_level_encoding = 4,
        statistics = 5,
    };
};

pub const IndexPageHeader = struct {
    pub const FieldTag = enum(i16) {};
};

pub const DictionaryPageHeader = struct {
    num_values: i32,
    encoding: Encoding,
    is_sorted: ?bool,

    pub const FieldTag = enum(i16) {
        num_values = 1,
        encoding = 2,
        is_sorted = 3,
    };
};

pub const DataPageHeaderV2 = struct {
    num_values: i32,
    num_nulls: i32,
    num_rows: i32,
    encoding: Encoding,
    definition_levels_byte_length: i32,
    repetition_levels_byte_length: i32,
    is_compressed: ?bool = true,
    statistics: ?Statistics,

    pub const FieldTag = enum(i16) {
        num_values = 1,
        num_nulls = 2,
        num_rows = 3,
        encoding = 4,
        definition_levels_byte_length = 5,
        repetition_levels_byte_length = 6,
        is_compressed = 7,
        statistics = 8,
    };
};

pub const SplitBlockAlgorithm = struct {
    pub const FieldTag = enum(i16) {};
};

pub const BloomFilterAlgorithm = union(enum) {
    BLOCK: SplitBlockAlgorithm,

    pub const FieldTag = enum(i16) {
        BLOCK = 1,
    };
};

pub const XxHash = struct {
    pub const FieldTag = enum(i16) {};
};

pub const BloomFilterHash = union(enum) {
    XXHASH: XxHash,

    pub const FieldTag = enum(i16) {
        XXHASH = 1,
    };
};

pub const Uncompressed = struct {
    pub const FieldTag = enum(i16) {};
};

pub const BloomFilterCompression = union(enum) {
    UNCOMPRESSED: Uncompressed,

    pub const FieldTag = enum(i16) {
        UNCOMPRESSED = 1,
    };
};

pub const BloomFilterHeader = struct {
    numBytes: i32,
    algorithm: BloomFilterAlgorithm,
    hash: BloomFilterHash,
    compression: BloomFilterCompression,

    pub const FieldTag = enum(i16) {
        numBytes = 1,
        algorithm = 2,
        hash = 3,
        compression = 4,
    };
};

pub const PageHeader = struct {
    type: PageType,
    uncompressed_page_size: i32,
    compressed_page_size: i32,
    crc: ?i32,
    data_page_header: ?DataPageHeader,
    index_page_header: ?IndexPageHeader,
    dictionary_page_header: ?DictionaryPageHeader,
    data_page_header_v2: ?DataPageHeaderV2,

    pub const FieldTag = enum(i16) {
        type = 1,
        uncompressed_page_size = 2,
        compressed_page_size = 3,
        crc = 4,
        data_page_header = 5,
        index_page_header = 6,
        dictionary_page_header = 7,
        data_page_header_v2 = 8,
    };
};

pub const KeyValue = struct {
    key: []const u8,
    value: ?[]const u8,

    pub const FieldTag = enum(i16) {
        key = 1,
        value = 2,
    };
};

pub const SortingColumn = struct {
    column_idx: i32,
    descending: bool,
    nulls_first: bool,

    pub const FieldTag = enum(i16) {
        column_idx = 1,
        descending = 2,
        nulls_first = 3,
    };
};

pub const PageEncodingStats = struct {
    page_type: PageType,
    encoding: Encoding,
    count: i32,

    pub const FieldTag = enum(i16) {
        page_type = 1,
        encoding = 2,
        count = 3,
    };
};

pub const ColumnMetaData = struct {
    type: Type,
    encodings: std.ArrayList(Encoding),
    path_in_schema: std.ArrayList([]const u8),
    codec: CompressionCodec,
    num_values: i64,
    total_uncompressed_size: i64,
    total_compressed_size: i64,
    key_value_metadata: ?std.ArrayList(KeyValue),
    data_page_offset: i64,
    index_page_offset: ?i64,
    dictionary_page_offset: ?i64,
    statistics: ?Statistics,
    encoding_stats: ?std.ArrayList(PageEncodingStats),
    bloom_filter_offset: ?i64,
    bloom_filter_length: ?i32,
    size_statistics: ?SizeStatistics,
    geospatial_statistics: ?GeospatialStatistics,

    pub const FieldTag = enum(i16) {
        type = 1,
        encodings = 2,
        path_in_schema = 3,
        codec = 4,
        num_values = 5,
        total_uncompressed_size = 6,
        total_compressed_size = 7,
        key_value_metadata = 8,
        data_page_offset = 9,
        index_page_offset = 10,
        dictionary_page_offset = 11,
        statistics = 12,
        encoding_stats = 13,
        bloom_filter_offset = 14,
        bloom_filter_length = 15,
        size_statistics = 16,
        geospatial_statistics = 17,
    };
};

pub const EncryptionWithFooterKey = struct {
    pub const FieldTag = enum(i16) {};
};

pub const EncryptionWithColumnKey = struct {
    path_in_schema: std.ArrayList([]const u8),
    key_metadata: ?[]const u8,

    pub const FieldTag = enum(i16) {
        path_in_schema = 1,
        key_metadata = 2,
    };
};

pub const ColumnCryptoMetaData = union(enum) {
    ENCRYPTION_WITH_FOOTER_KEY: EncryptionWithFooterKey,
    ENCRYPTION_WITH_COLUMN_KEY: EncryptionWithColumnKey,

    pub const FieldTag = enum(i16) {
        ENCRYPTION_WITH_FOOTER_KEY = 1,
        ENCRYPTION_WITH_COLUMN_KEY = 2,
    };
};

pub const ColumnChunk = struct {
    file_path: ?[]const u8,
    file_offset: i64 = 0,
    meta_data: ?ColumnMetaData,
    offset_index_offset: ?i64,
    offset_index_length: ?i32,
    column_index_offset: ?i64,
    column_index_length: ?i32,
    crypto_metadata: ?ColumnCryptoMetaData,
    encrypted_column_metadata: ?[]const u8,

    pub const FieldTag = enum(i16) {
        file_path = 1,
        file_offset = 2,
        meta_data = 3,
        offset_index_offset = 4,
        offset_index_length = 5,
        column_index_offset = 6,
        column_index_length = 7,
        crypto_metadata = 8,
        encrypted_column_metadata = 9,
    };
};

pub const RowGroup = struct {
    columns: std.ArrayList(ColumnChunk),
    total_byte_size: i64,
    num_rows: i64,
    sorting_columns: ?std.ArrayList(SortingColumn),
    file_offset: ?i64,
    total_compressed_size: ?i64,
    ordinal: ?i16,

    pub const FieldTag = enum(i16) {
        columns = 1,
        total_byte_size = 2,
        num_rows = 3,
        sorting_columns = 4,
        file_offset = 5,
        total_compressed_size = 6,
        ordinal = 7,
    };
};

pub const TypeDefinedOrder = struct {
    dummy: ?i8,

    pub const FieldTag = enum(i16) {
        dummy = 1,
    };
};

pub const ColumnOrder = union(enum) {
    TYPE_ORDER: TypeDefinedOrder,

    pub const FieldTag = enum(i16) {
        TYPE_ORDER = 1,
    };
};

pub const PageLocation = struct {
    offset: i64,
    compressed_page_size: i32,
    first_row_index: i64,

    pub const FieldTag = enum(i16) {
        offset = 1,
        compressed_page_size = 2,
        first_row_index = 3,
    };
};

pub const OffsetIndex = struct {
    page_locations: std.ArrayList(PageLocation),
    unencoded_byte_array_data_bytes: ?std.ArrayList(i64),

    pub const FieldTag = enum(i16) {
        page_locations = 1,
        unencoded_byte_array_data_bytes = 2,
    };
};

pub const ColumnIndex = struct {
    null_pages: std.ArrayList(bool),
    min_values: std.ArrayList([]const u8),
    max_values: std.ArrayList([]const u8),
    boundary_order: BoundaryOrder,
    null_counts: ?std.ArrayList(i64),
    repetition_level_histograms: ?std.ArrayList(i64),
    definition_level_histograms: ?std.ArrayList(i64),

    pub const FieldTag = enum(i16) {
        null_pages = 1,
        min_values = 2,
        max_values = 3,
        boundary_order = 4,
        null_counts = 5,
        repetition_level_histograms = 6,
        definition_level_histograms = 7,
    };
};

pub const AesGcmV1 = struct {
    aad_prefix: ?[]const u8,
    aad_file_unique: ?[]const u8,
    supply_aad_prefix: ?bool,

    pub const FieldTag = enum(i16) {
        aad_prefix = 1,
        aad_file_unique = 2,
        supply_aad_prefix = 3,
    };
};

pub const AesGcmCtrV1 = struct {
    aad_prefix: ?[]const u8,
    aad_file_unique: ?[]const u8,
    supply_aad_prefix: ?bool,

    pub const FieldTag = enum(i16) {
        aad_prefix = 1,
        aad_file_unique = 2,
        supply_aad_prefix = 3,
    };
};

pub const EncryptionAlgorithm = union(enum) {
    AES_GCM_V1: AesGcmV1,
    AES_GCM_CTR_V1: AesGcmCtrV1,

    pub const FieldTag = enum(i16) {
        AES_GCM_V1 = 1,
        AES_GCM_CTR_V1 = 2,
    };
};

pub const FileMetaData = struct {
    version: i32,
    schema: std.ArrayList(SchemaElement),
    num_rows: i64,
    row_groups: std.ArrayList(RowGroup),
    key_value_metadata: ?std.ArrayList(KeyValue),
    created_by: ?[]const u8,
    column_orders: ?std.ArrayList(ColumnOrder),
    encryption_algorithm: ?EncryptionAlgorithm,
    footer_signing_key_metadata: ?[]const u8,

    pub const FieldTag = enum(i16) {
        version = 1,
        schema = 2,
        num_rows = 3,
        row_groups = 4,
        key_value_metadata = 5,
        created_by = 6,
        column_orders = 7,
        encryption_algorithm = 8,
        footer_signing_key_metadata = 9,
    };
};

pub const FileCryptoMetaData = struct {
    encryption_algorithm: EncryptionAlgorithm,
    key_metadata: ?[]const u8,

    pub const FieldTag = enum(i16) {
        encryption_algorithm = 1,
        key_metadata = 2,
    };
};

test "generated code compiles, writes, and reads structs & unions" {
    var buf: [100000]u8 = undefined;
    const alloc = std.testing.allocator;
    // var arena = std.heap.ArenaAllocator.init(std.testing.allocator);
    // const alloc = arena.allocator();
    // defer arena.deinit();

    var w: Writer = undefined;
    w.init(.fixed(&buf));

    var struct0: SizeStatistics = SizeStatistics{ .unencoded_byte_array_data_bytes = 123456789, .repetition_level_histogram = std.ArrayList(i64).empty, .definition_level_histogram = std.ArrayList(i64).empty };
    struct0.repetition_level_histogram = std.ArrayList(i64).empty;
    if (@sizeOf(i64) > 0) {
        try struct0.repetition_level_histogram.?.ensureTotalCapacity(alloc, 2);
        try struct0.repetition_level_histogram.?.append(alloc, 123456789);
        try struct0.repetition_level_histogram.?.append(alloc, 123456789);
    }
    defer struct0.repetition_level_histogram.?.deinit(alloc);
    struct0.definition_level_histogram = std.ArrayList(i64).empty;
    if (@sizeOf(i64) > 0) {
        try struct0.definition_level_histogram.?.ensureTotalCapacity(alloc, 2);
        try struct0.definition_level_histogram.?.append(alloc, 123456789);
        try struct0.definition_level_histogram.?.append(alloc, 123456789);
    }
    defer struct0.definition_level_histogram.?.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct0), struct0, &w);
    const struct1: BoundingBox = BoundingBox{ .xmin = 3.14, .xmax = 3.14, .ymin = 3.14, .ymax = 3.14, .zmin = 3.14, .zmax = 3.14, .mmin = 3.14, .mmax = 3.14 };
    try Meta.structWrite(@TypeOf(struct1), struct1, &w);
    var struct2: GeospatialStatistics = GeospatialStatistics{ .bbox = BoundingBox{ .xmin = 3.14, .xmax = 3.14, .ymin = 3.14, .ymax = 3.14, .zmin = 3.14, .zmax = 3.14, .mmin = 3.14, .mmax = 3.14 }, .geospatial_types = std.ArrayList(i32).empty };
    struct2.geospatial_types = std.ArrayList(i32).empty;
    if (@sizeOf(i32) > 0) {
        try struct2.geospatial_types.?.ensureTotalCapacity(alloc, 2);
        try struct2.geospatial_types.?.append(alloc, 12345);
        try struct2.geospatial_types.?.append(alloc, 12345);
    }
    defer struct2.geospatial_types.?.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct2), struct2, &w);
    const struct3: Statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true };
    try Meta.structWrite(@TypeOf(struct3), struct3, &w);
    const struct4: StringType = StringType{};
    try Meta.structWrite(@TypeOf(struct4), struct4, &w);
    const struct5: UUIDType = UUIDType{};
    try Meta.structWrite(@TypeOf(struct5), struct5, &w);
    const struct6: MapType = MapType{};
    try Meta.structWrite(@TypeOf(struct6), struct6, &w);
    const struct7: ListType = ListType{};
    try Meta.structWrite(@TypeOf(struct7), struct7, &w);
    const struct8: EnumType = EnumType{};
    try Meta.structWrite(@TypeOf(struct8), struct8, &w);
    const struct9: DateType = DateType{};
    try Meta.structWrite(@TypeOf(struct9), struct9, &w);
    const struct10: Float16Type = Float16Type{};
    try Meta.structWrite(@TypeOf(struct10), struct10, &w);
    const struct11: NullType = NullType{};
    try Meta.structWrite(@TypeOf(struct11), struct11, &w);
    const struct12: DecimalType = DecimalType{ .scale = 12345, .precision = 12345 };
    try Meta.structWrite(@TypeOf(struct12), struct12, &w);
    const struct13: MilliSeconds = MilliSeconds{};
    try Meta.structWrite(@TypeOf(struct13), struct13, &w);
    const struct14: MicroSeconds = MicroSeconds{};
    try Meta.structWrite(@TypeOf(struct14), struct14, &w);
    const struct15: NanoSeconds = NanoSeconds{};
    try Meta.structWrite(@TypeOf(struct15), struct15, &w);
    const union0: TimeUnit = .{ .MILLIS = MilliSeconds{} };
    try Meta.unionWrite(@TypeOf(union0), union0, &w);
    const struct16: TimestampType = TimestampType{ .isAdjustedToUTC = true, .unit = .{ .MILLIS = MilliSeconds{} } };
    try Meta.structWrite(@TypeOf(struct16), struct16, &w);
    const struct17: TimeType = TimeType{ .isAdjustedToUTC = true, .unit = .{ .MILLIS = MilliSeconds{} } };
    try Meta.structWrite(@TypeOf(struct17), struct17, &w);
    const struct18: IntType = IntType{ .bitWidth = 12, .isSigned = true };
    try Meta.structWrite(@TypeOf(struct18), struct18, &w);
    const struct19: JsonType = JsonType{};
    try Meta.structWrite(@TypeOf(struct19), struct19, &w);
    const struct20: BsonType = BsonType{};
    try Meta.structWrite(@TypeOf(struct20), struct20, &w);
    const struct21: VariantType = VariantType{ .specification_version = 12 };
    try Meta.structWrite(@TypeOf(struct21), struct21, &w);
    const struct22: GeometryType = GeometryType{ .crs = "hello world" };
    try Meta.structWrite(@TypeOf(struct22), struct22, &w);
    const struct23: GeographyType = GeographyType{ .crs = "hello world", .algorithm = .SPHERICAL };
    try Meta.structWrite(@TypeOf(struct23), struct23, &w);
    const union1: LogicalType = .{ .STRING = StringType{} };
    try Meta.unionWrite(@TypeOf(union1), union1, &w);
    const struct24: SchemaElement = SchemaElement{ .type = .BOOLEAN, .type_length = 12345, .repetition_type = .REQUIRED, .name = "hello world", .num_children = 12345, .converted_type = .UTF8, .scale = 12345, .precision = 12345, .field_id = 12345, .logicalType = .{ .STRING = StringType{} } };
    try Meta.structWrite(@TypeOf(struct24), struct24, &w);
    const struct25: DataPageHeader = DataPageHeader{ .num_values = 12345, .encoding = .PLAIN, .definition_level_encoding = .PLAIN, .repetition_level_encoding = .PLAIN, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true } };
    try Meta.structWrite(@TypeOf(struct25), struct25, &w);
    const struct26: IndexPageHeader = IndexPageHeader{};
    try Meta.structWrite(@TypeOf(struct26), struct26, &w);
    const struct27: DictionaryPageHeader = DictionaryPageHeader{ .num_values = 12345, .encoding = .PLAIN, .is_sorted = true };
    try Meta.structWrite(@TypeOf(struct27), struct27, &w);
    const struct28: DataPageHeaderV2 = DataPageHeaderV2{ .num_values = 12345, .num_nulls = 12345, .num_rows = 12345, .encoding = .PLAIN, .definition_levels_byte_length = 12345, .repetition_levels_byte_length = 12345, .is_compressed = true, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true } };
    try Meta.structWrite(@TypeOf(struct28), struct28, &w);
    const struct29: SplitBlockAlgorithm = SplitBlockAlgorithm{};
    try Meta.structWrite(@TypeOf(struct29), struct29, &w);
    const union2: BloomFilterAlgorithm = .{ .BLOCK = SplitBlockAlgorithm{} };
    try Meta.unionWrite(@TypeOf(union2), union2, &w);
    const struct30: XxHash = XxHash{};
    try Meta.structWrite(@TypeOf(struct30), struct30, &w);
    const union3: BloomFilterHash = .{ .XXHASH = XxHash{} };
    try Meta.unionWrite(@TypeOf(union3), union3, &w);
    const struct31: Uncompressed = Uncompressed{};
    try Meta.structWrite(@TypeOf(struct31), struct31, &w);
    const union4: BloomFilterCompression = .{ .UNCOMPRESSED = Uncompressed{} };
    try Meta.unionWrite(@TypeOf(union4), union4, &w);
    const struct32: BloomFilterHeader = BloomFilterHeader{ .numBytes = 12345, .algorithm = .{ .BLOCK = SplitBlockAlgorithm{} }, .hash = .{ .XXHASH = XxHash{} }, .compression = .{ .UNCOMPRESSED = Uncompressed{} } };
    try Meta.structWrite(@TypeOf(struct32), struct32, &w);
    const struct33: PageHeader = PageHeader{ .type = .DATA_PAGE, .uncompressed_page_size = 12345, .compressed_page_size = 12345, .crc = 12345, .data_page_header = DataPageHeader{ .num_values = 12345, .encoding = .PLAIN, .definition_level_encoding = .PLAIN, .repetition_level_encoding = .PLAIN, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true } }, .index_page_header = IndexPageHeader{}, .dictionary_page_header = DictionaryPageHeader{ .num_values = 12345, .encoding = .PLAIN, .is_sorted = true }, .data_page_header_v2 = DataPageHeaderV2{ .num_values = 12345, .num_nulls = 12345, .num_rows = 12345, .encoding = .PLAIN, .definition_levels_byte_length = 12345, .repetition_levels_byte_length = 12345, .is_compressed = true, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true } } };
    try Meta.structWrite(@TypeOf(struct33), struct33, &w);
    const struct34: KeyValue = KeyValue{ .key = "hello world", .value = "hello world" };
    try Meta.structWrite(@TypeOf(struct34), struct34, &w);
    const struct35: SortingColumn = SortingColumn{ .column_idx = 12345, .descending = true, .nulls_first = true };
    try Meta.structWrite(@TypeOf(struct35), struct35, &w);
    const struct36: PageEncodingStats = PageEncodingStats{ .page_type = .DATA_PAGE, .encoding = .PLAIN, .count = 12345 };
    try Meta.structWrite(@TypeOf(struct36), struct36, &w);
    var struct37: ColumnMetaData = ColumnMetaData{ .type = .BOOLEAN, .encodings = std.ArrayList(Encoding).empty, .path_in_schema = std.ArrayList([]const u8).empty, .codec = .UNCOMPRESSED, .num_values = 123456789, .total_uncompressed_size = 123456789, .total_compressed_size = 123456789, .key_value_metadata = std.ArrayList(KeyValue).empty, .data_page_offset = 123456789, .index_page_offset = 123456789, .dictionary_page_offset = 123456789, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true }, .encoding_stats = std.ArrayList(PageEncodingStats).empty, .bloom_filter_offset = 123456789, .bloom_filter_length = 12345, .size_statistics = SizeStatistics{ .unencoded_byte_array_data_bytes = 123456789, .repetition_level_histogram = std.ArrayList(i64).empty, .definition_level_histogram = std.ArrayList(i64).empty }, .geospatial_statistics = GeospatialStatistics{ .bbox = BoundingBox{ .xmin = 3.14, .xmax = 3.14, .ymin = 3.14, .ymax = 3.14, .zmin = 3.14, .zmax = 3.14, .mmin = 3.14, .mmax = 3.14 }, .geospatial_types = std.ArrayList(i32).empty } };
    if (@sizeOf(Encoding) > 0) {
        try struct37.encodings.ensureTotalCapacity(alloc, 2);
        try struct37.encodings.append(alloc, .PLAIN);
        try struct37.encodings.append(alloc, .PLAIN);
    }
    defer struct37.encodings.deinit(alloc);
    if (@sizeOf([]const u8) > 0) {
        try struct37.path_in_schema.ensureTotalCapacity(alloc, 2);
        try struct37.path_in_schema.append(alloc, "hello world");
        try struct37.path_in_schema.append(alloc, "hello world");
    }
    defer struct37.path_in_schema.deinit(alloc);
    struct37.key_value_metadata = std.ArrayList(KeyValue).empty;
    if (@sizeOf(KeyValue) > 0) {
        try struct37.key_value_metadata.?.ensureTotalCapacity(alloc, 2);
        try struct37.key_value_metadata.?.append(alloc, KeyValue{ .key = "hello world", .value = "hello world" });
        try struct37.key_value_metadata.?.append(alloc, KeyValue{ .key = "hello world", .value = "hello world" });
    }
    defer struct37.key_value_metadata.?.deinit(alloc);
    struct37.encoding_stats = std.ArrayList(PageEncodingStats).empty;
    if (@sizeOf(PageEncodingStats) > 0) {
        try struct37.encoding_stats.?.ensureTotalCapacity(alloc, 2);
        try struct37.encoding_stats.?.append(alloc, PageEncodingStats{ .page_type = .DATA_PAGE, .encoding = .PLAIN, .count = 12345 });
        try struct37.encoding_stats.?.append(alloc, PageEncodingStats{ .page_type = .DATA_PAGE, .encoding = .PLAIN, .count = 12345 });
    }
    defer struct37.encoding_stats.?.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct37), struct37, &w);
    const struct38: EncryptionWithFooterKey = EncryptionWithFooterKey{};
    try Meta.structWrite(@TypeOf(struct38), struct38, &w);
    var struct39: EncryptionWithColumnKey = EncryptionWithColumnKey{ .path_in_schema = std.ArrayList([]const u8).empty, .key_metadata = "hello world" };
    if (@sizeOf([]const u8) > 0) {
        try struct39.path_in_schema.ensureTotalCapacity(alloc, 2);
        try struct39.path_in_schema.append(alloc, "hello world");
        try struct39.path_in_schema.append(alloc, "hello world");
    }
    defer struct39.path_in_schema.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct39), struct39, &w);
    const union5: ColumnCryptoMetaData = .{ .ENCRYPTION_WITH_FOOTER_KEY = EncryptionWithFooterKey{} };
    try Meta.unionWrite(@TypeOf(union5), union5, &w);
    const struct40: ColumnChunk = ColumnChunk{ .file_path = "hello world", .file_offset = 123456789, .meta_data = ColumnMetaData{ .type = .BOOLEAN, .encodings = std.ArrayList(Encoding).empty, .path_in_schema = std.ArrayList([]const u8).empty, .codec = .UNCOMPRESSED, .num_values = 123456789, .total_uncompressed_size = 123456789, .total_compressed_size = 123456789, .key_value_metadata = std.ArrayList(KeyValue).empty, .data_page_offset = 123456789, .index_page_offset = 123456789, .dictionary_page_offset = 123456789, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true }, .encoding_stats = std.ArrayList(PageEncodingStats).empty, .bloom_filter_offset = 123456789, .bloom_filter_length = 12345, .size_statistics = SizeStatistics{ .unencoded_byte_array_data_bytes = 123456789, .repetition_level_histogram = std.ArrayList(i64).empty, .definition_level_histogram = std.ArrayList(i64).empty }, .geospatial_statistics = GeospatialStatistics{ .bbox = BoundingBox{ .xmin = 3.14, .xmax = 3.14, .ymin = 3.14, .ymax = 3.14, .zmin = 3.14, .zmax = 3.14, .mmin = 3.14, .mmax = 3.14 }, .geospatial_types = std.ArrayList(i32).empty } }, .offset_index_offset = 123456789, .offset_index_length = 12345, .column_index_offset = 123456789, .column_index_length = 12345, .crypto_metadata = .{ .ENCRYPTION_WITH_FOOTER_KEY = EncryptionWithFooterKey{} }, .encrypted_column_metadata = "hello world" };
    try Meta.structWrite(@TypeOf(struct40), struct40, &w);
    var struct41: RowGroup = RowGroup{ .columns = std.ArrayList(ColumnChunk).empty, .total_byte_size = 123456789, .num_rows = 123456789, .sorting_columns = std.ArrayList(SortingColumn).empty, .file_offset = 123456789, .total_compressed_size = 123456789, .ordinal = 123 };
    if (@sizeOf(ColumnChunk) > 0) {
        try struct41.columns.ensureTotalCapacity(alloc, 2);
        try struct41.columns.append(alloc, ColumnChunk{ .file_path = "hello world", .file_offset = 123456789, .meta_data = ColumnMetaData{ .type = .BOOLEAN, .encodings = std.ArrayList(Encoding).empty, .path_in_schema = std.ArrayList([]const u8).empty, .codec = .UNCOMPRESSED, .num_values = 123456789, .total_uncompressed_size = 123456789, .total_compressed_size = 123456789, .key_value_metadata = std.ArrayList(KeyValue).empty, .data_page_offset = 123456789, .index_page_offset = 123456789, .dictionary_page_offset = 123456789, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true }, .encoding_stats = std.ArrayList(PageEncodingStats).empty, .bloom_filter_offset = 123456789, .bloom_filter_length = 12345, .size_statistics = SizeStatistics{ .unencoded_byte_array_data_bytes = 123456789, .repetition_level_histogram = std.ArrayList(i64).empty, .definition_level_histogram = std.ArrayList(i64).empty }, .geospatial_statistics = GeospatialStatistics{ .bbox = BoundingBox{ .xmin = 3.14, .xmax = 3.14, .ymin = 3.14, .ymax = 3.14, .zmin = 3.14, .zmax = 3.14, .mmin = 3.14, .mmax = 3.14 }, .geospatial_types = std.ArrayList(i32).empty } }, .offset_index_offset = 123456789, .offset_index_length = 12345, .column_index_offset = 123456789, .column_index_length = 12345, .crypto_metadata = .{ .ENCRYPTION_WITH_FOOTER_KEY = EncryptionWithFooterKey{} }, .encrypted_column_metadata = "hello world" });
        try struct41.columns.append(alloc, ColumnChunk{ .file_path = "hello world", .file_offset = 123456789, .meta_data = ColumnMetaData{ .type = .BOOLEAN, .encodings = std.ArrayList(Encoding).empty, .path_in_schema = std.ArrayList([]const u8).empty, .codec = .UNCOMPRESSED, .num_values = 123456789, .total_uncompressed_size = 123456789, .total_compressed_size = 123456789, .key_value_metadata = std.ArrayList(KeyValue).empty, .data_page_offset = 123456789, .index_page_offset = 123456789, .dictionary_page_offset = 123456789, .statistics = Statistics{ .max = "hello world", .min = "hello world", .null_count = 123456789, .distinct_count = 123456789, .max_value = "hello world", .min_value = "hello world", .is_max_value_exact = true, .is_min_value_exact = true }, .encoding_stats = std.ArrayList(PageEncodingStats).empty, .bloom_filter_offset = 123456789, .bloom_filter_length = 12345, .size_statistics = SizeStatistics{ .unencoded_byte_array_data_bytes = 123456789, .repetition_level_histogram = std.ArrayList(i64).empty, .definition_level_histogram = std.ArrayList(i64).empty }, .geospatial_statistics = GeospatialStatistics{ .bbox = BoundingBox{ .xmin = 3.14, .xmax = 3.14, .ymin = 3.14, .ymax = 3.14, .zmin = 3.14, .zmax = 3.14, .mmin = 3.14, .mmax = 3.14 }, .geospatial_types = std.ArrayList(i32).empty } }, .offset_index_offset = 123456789, .offset_index_length = 12345, .column_index_offset = 123456789, .column_index_length = 12345, .crypto_metadata = .{ .ENCRYPTION_WITH_FOOTER_KEY = EncryptionWithFooterKey{} }, .encrypted_column_metadata = "hello world" });
    }
    defer struct41.columns.deinit(alloc);
    struct41.sorting_columns = std.ArrayList(SortingColumn).empty;
    if (@sizeOf(SortingColumn) > 0) {
        try struct41.sorting_columns.?.ensureTotalCapacity(alloc, 2);
        try struct41.sorting_columns.?.append(alloc, SortingColumn{ .column_idx = 12345, .descending = true, .nulls_first = true });
        try struct41.sorting_columns.?.append(alloc, SortingColumn{ .column_idx = 12345, .descending = true, .nulls_first = true });
    }
    defer struct41.sorting_columns.?.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct41), struct41, &w);
    const struct42: TypeDefinedOrder = TypeDefinedOrder{ .dummy = 12 };
    try Meta.structWrite(@TypeOf(struct42), struct42, &w);
    const union6: ColumnOrder = .{ .TYPE_ORDER = TypeDefinedOrder{ .dummy = 12 } };
    try Meta.unionWrite(@TypeOf(union6), union6, &w);
    const struct43: PageLocation = PageLocation{ .offset = 123456789, .compressed_page_size = 12345, .first_row_index = 123456789 };
    try Meta.structWrite(@TypeOf(struct43), struct43, &w);
    var struct44: OffsetIndex = OffsetIndex{ .page_locations = std.ArrayList(PageLocation).empty, .unencoded_byte_array_data_bytes = std.ArrayList(i64).empty };
    if (@sizeOf(PageLocation) > 0) {
        try struct44.page_locations.ensureTotalCapacity(alloc, 2);
        try struct44.page_locations.append(alloc, PageLocation{ .offset = 123456789, .compressed_page_size = 12345, .first_row_index = 123456789 });
        try struct44.page_locations.append(alloc, PageLocation{ .offset = 123456789, .compressed_page_size = 12345, .first_row_index = 123456789 });
    }
    defer struct44.page_locations.deinit(alloc);
    struct44.unencoded_byte_array_data_bytes = std.ArrayList(i64).empty;
    if (@sizeOf(i64) > 0) {
        try struct44.unencoded_byte_array_data_bytes.?.ensureTotalCapacity(alloc, 2);
        try struct44.unencoded_byte_array_data_bytes.?.append(alloc, 123456789);
        try struct44.unencoded_byte_array_data_bytes.?.append(alloc, 123456789);
    }
    defer struct44.unencoded_byte_array_data_bytes.?.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct44), struct44, &w);
    var struct45: ColumnIndex = ColumnIndex{ .null_pages = std.ArrayList(bool).empty, .min_values = std.ArrayList([]const u8).empty, .max_values = std.ArrayList([]const u8).empty, .boundary_order = .UNORDERED, .null_counts = std.ArrayList(i64).empty, .repetition_level_histograms = std.ArrayList(i64).empty, .definition_level_histograms = std.ArrayList(i64).empty };
    if (@sizeOf(bool) > 0) {
        try struct45.null_pages.ensureTotalCapacity(alloc, 2);
        try struct45.null_pages.append(alloc, true);
        try struct45.null_pages.append(alloc, true);
    }
    defer struct45.null_pages.deinit(alloc);
    if (@sizeOf([]const u8) > 0) {
        try struct45.min_values.ensureTotalCapacity(alloc, 2);
        try struct45.min_values.append(alloc, "hello world");
        try struct45.min_values.append(alloc, "hello world");
    }
    defer struct45.min_values.deinit(alloc);
    if (@sizeOf([]const u8) > 0) {
        try struct45.max_values.ensureTotalCapacity(alloc, 2);
        try struct45.max_values.append(alloc, "hello world");
        try struct45.max_values.append(alloc, "hello world");
    }
    defer struct45.max_values.deinit(alloc);
    struct45.null_counts = std.ArrayList(i64).empty;
    if (@sizeOf(i64) > 0) {
        try struct45.null_counts.?.ensureTotalCapacity(alloc, 2);
        try struct45.null_counts.?.append(alloc, 123456789);
        try struct45.null_counts.?.append(alloc, 123456789);
    }
    defer struct45.null_counts.?.deinit(alloc);
    struct45.repetition_level_histograms = std.ArrayList(i64).empty;
    if (@sizeOf(i64) > 0) {
        try struct45.repetition_level_histograms.?.ensureTotalCapacity(alloc, 2);
        try struct45.repetition_level_histograms.?.append(alloc, 123456789);
        try struct45.repetition_level_histograms.?.append(alloc, 123456789);
    }
    defer struct45.repetition_level_histograms.?.deinit(alloc);
    struct45.definition_level_histograms = std.ArrayList(i64).empty;
    if (@sizeOf(i64) > 0) {
        try struct45.definition_level_histograms.?.ensureTotalCapacity(alloc, 2);
        try struct45.definition_level_histograms.?.append(alloc, 123456789);
        try struct45.definition_level_histograms.?.append(alloc, 123456789);
    }
    defer struct45.definition_level_histograms.?.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct45), struct45, &w);
    const struct46: AesGcmV1 = AesGcmV1{ .aad_prefix = "hello world", .aad_file_unique = "hello world", .supply_aad_prefix = true };
    try Meta.structWrite(@TypeOf(struct46), struct46, &w);
    const struct47: AesGcmCtrV1 = AesGcmCtrV1{ .aad_prefix = "hello world", .aad_file_unique = "hello world", .supply_aad_prefix = true };
    try Meta.structWrite(@TypeOf(struct47), struct47, &w);
    const union7: EncryptionAlgorithm = .{ .AES_GCM_V1 = AesGcmV1{ .aad_prefix = "hello world", .aad_file_unique = "hello world", .supply_aad_prefix = true } };
    try Meta.unionWrite(@TypeOf(union7), union7, &w);
    var struct48: FileMetaData = FileMetaData{ .version = 12345, .schema = std.ArrayList(SchemaElement).empty, .num_rows = 123456789, .row_groups = std.ArrayList(RowGroup).empty, .key_value_metadata = std.ArrayList(KeyValue).empty, .created_by = "hello world", .column_orders = std.ArrayList(ColumnOrder).empty, .encryption_algorithm = .{ .AES_GCM_V1 = AesGcmV1{ .aad_prefix = "hello world", .aad_file_unique = "hello world", .supply_aad_prefix = true } }, .footer_signing_key_metadata = "hello world" };
    if (@sizeOf(SchemaElement) > 0) {
        try struct48.schema.ensureTotalCapacity(alloc, 2);
        try struct48.schema.append(alloc, SchemaElement{ .type = .BOOLEAN, .type_length = 12345, .repetition_type = .REQUIRED, .name = "hello world", .num_children = 12345, .converted_type = .UTF8, .scale = 12345, .precision = 12345, .field_id = 12345, .logicalType = .{ .STRING = StringType{} } });
        try struct48.schema.append(alloc, SchemaElement{ .type = .BOOLEAN, .type_length = 12345, .repetition_type = .REQUIRED, .name = "hello world", .num_children = 12345, .converted_type = .UTF8, .scale = 12345, .precision = 12345, .field_id = 12345, .logicalType = .{ .STRING = StringType{} } });
    }
    defer struct48.schema.deinit(alloc);
    if (@sizeOf(RowGroup) > 0) {
        try struct48.row_groups.ensureTotalCapacity(alloc, 2);
        try struct48.row_groups.append(alloc, RowGroup{ .columns = std.ArrayList(ColumnChunk).empty, .total_byte_size = 123456789, .num_rows = 123456789, .sorting_columns = std.ArrayList(SortingColumn).empty, .file_offset = 123456789, .total_compressed_size = 123456789, .ordinal = 123 });
        try struct48.row_groups.append(alloc, RowGroup{ .columns = std.ArrayList(ColumnChunk).empty, .total_byte_size = 123456789, .num_rows = 123456789, .sorting_columns = std.ArrayList(SortingColumn).empty, .file_offset = 123456789, .total_compressed_size = 123456789, .ordinal = 123 });
    }
    defer struct48.row_groups.deinit(alloc);
    struct48.key_value_metadata = std.ArrayList(KeyValue).empty;
    if (@sizeOf(KeyValue) > 0) {
        try struct48.key_value_metadata.?.ensureTotalCapacity(alloc, 2);
        try struct48.key_value_metadata.?.append(alloc, KeyValue{ .key = "hello world", .value = "hello world" });
        try struct48.key_value_metadata.?.append(alloc, KeyValue{ .key = "hello world", .value = "hello world" });
    }
    defer struct48.key_value_metadata.?.deinit(alloc);
    struct48.column_orders = std.ArrayList(ColumnOrder).empty;
    if (@sizeOf(ColumnOrder) > 0) {
        try struct48.column_orders.?.ensureTotalCapacity(alloc, 2);
        try struct48.column_orders.?.append(alloc, .{ .TYPE_ORDER = TypeDefinedOrder{ .dummy = 12 } });
        try struct48.column_orders.?.append(alloc, .{ .TYPE_ORDER = TypeDefinedOrder{ .dummy = 12 } });
    }
    defer struct48.column_orders.?.deinit(alloc);
    try Meta.structWrite(@TypeOf(struct48), struct48, &w);
    const struct49: FileCryptoMetaData = FileCryptoMetaData{ .encryption_algorithm = .{ .AES_GCM_V1 = AesGcmV1{ .aad_prefix = "hello world", .aad_file_unique = "hello world", .supply_aad_prefix = true } }, .key_metadata = "hello world" };
    try Meta.structWrite(@TypeOf(struct49), struct49, &w);
    const written: []const u8 = w.writer.buffered();
    var r: Reader = undefined;
    r.init(.fixed(written));
    const struct0_read = try Meta.structRead(SizeStatistics, alloc, &r);
    defer Meta.deinit(SizeStatistics, struct0_read, alloc);
    try Meta.expectEqualDeep(struct0, struct0_read);
    const struct1_read = try Meta.structRead(BoundingBox, alloc, &r);
    defer Meta.deinit(BoundingBox, struct1_read, alloc);
    try Meta.expectEqualDeep(struct1, struct1_read);
    const struct2_read = try Meta.structRead(GeospatialStatistics, alloc, &r);
    defer Meta.deinit(GeospatialStatistics, struct2_read, alloc);
    try Meta.expectEqualDeep(struct2, struct2_read);
    const struct3_read = try Meta.structRead(Statistics, alloc, &r);
    defer Meta.deinit(Statistics, struct3_read, alloc);
    try Meta.expectEqualDeep(struct3, struct3_read);
    const struct4_read = try Meta.structRead(StringType, alloc, &r);
    defer Meta.deinit(StringType, struct4_read, alloc);
    try Meta.expectEqualDeep(struct4, struct4_read);
    const struct5_read = try Meta.structRead(UUIDType, alloc, &r);
    defer Meta.deinit(UUIDType, struct5_read, alloc);
    try Meta.expectEqualDeep(struct5, struct5_read);
    const struct6_read = try Meta.structRead(MapType, alloc, &r);
    defer Meta.deinit(MapType, struct6_read, alloc);
    try Meta.expectEqualDeep(struct6, struct6_read);
    const struct7_read = try Meta.structRead(ListType, alloc, &r);
    defer Meta.deinit(ListType, struct7_read, alloc);
    try Meta.expectEqualDeep(struct7, struct7_read);
    const struct8_read = try Meta.structRead(EnumType, alloc, &r);
    defer Meta.deinit(EnumType, struct8_read, alloc);
    try Meta.expectEqualDeep(struct8, struct8_read);
    const struct9_read = try Meta.structRead(DateType, alloc, &r);
    defer Meta.deinit(DateType, struct9_read, alloc);
    try Meta.expectEqualDeep(struct9, struct9_read);
    const struct10_read = try Meta.structRead(Float16Type, alloc, &r);
    defer Meta.deinit(Float16Type, struct10_read, alloc);
    try Meta.expectEqualDeep(struct10, struct10_read);
    const struct11_read = try Meta.structRead(NullType, alloc, &r);
    defer Meta.deinit(NullType, struct11_read, alloc);
    try Meta.expectEqualDeep(struct11, struct11_read);
    const struct12_read = try Meta.structRead(DecimalType, alloc, &r);
    defer Meta.deinit(DecimalType, struct12_read, alloc);
    try Meta.expectEqualDeep(struct12, struct12_read);
    const struct13_read = try Meta.structRead(MilliSeconds, alloc, &r);
    defer Meta.deinit(MilliSeconds, struct13_read, alloc);
    try Meta.expectEqualDeep(struct13, struct13_read);
    const struct14_read = try Meta.structRead(MicroSeconds, alloc, &r);
    defer Meta.deinit(MicroSeconds, struct14_read, alloc);
    try Meta.expectEqualDeep(struct14, struct14_read);
    const struct15_read = try Meta.structRead(NanoSeconds, alloc, &r);
    defer Meta.deinit(NanoSeconds, struct15_read, alloc);
    try Meta.expectEqualDeep(struct15, struct15_read);
    const union0_read = try Meta.unionRead(TimeUnit, alloc, &r);
    defer Meta.deinit(TimeUnit, union0_read, alloc);
    try Meta.expectEqualDeep(union0, union0_read);
    const struct16_read = try Meta.structRead(TimestampType, alloc, &r);
    defer Meta.deinit(TimestampType, struct16_read, alloc);
    try Meta.expectEqualDeep(struct16, struct16_read);
    const struct17_read = try Meta.structRead(TimeType, alloc, &r);
    defer Meta.deinit(TimeType, struct17_read, alloc);
    try Meta.expectEqualDeep(struct17, struct17_read);
    const struct18_read = try Meta.structRead(IntType, alloc, &r);
    defer Meta.deinit(IntType, struct18_read, alloc);
    try Meta.expectEqualDeep(struct18, struct18_read);
    const struct19_read = try Meta.structRead(JsonType, alloc, &r);
    defer Meta.deinit(JsonType, struct19_read, alloc);
    try Meta.expectEqualDeep(struct19, struct19_read);
    const struct20_read = try Meta.structRead(BsonType, alloc, &r);
    defer Meta.deinit(BsonType, struct20_read, alloc);
    try Meta.expectEqualDeep(struct20, struct20_read);
    const struct21_read = try Meta.structRead(VariantType, alloc, &r);
    defer Meta.deinit(VariantType, struct21_read, alloc);
    try Meta.expectEqualDeep(struct21, struct21_read);
    const struct22_read = try Meta.structRead(GeometryType, alloc, &r);
    defer Meta.deinit(GeometryType, struct22_read, alloc);
    try Meta.expectEqualDeep(struct22, struct22_read);
    const struct23_read = try Meta.structRead(GeographyType, alloc, &r);
    defer Meta.deinit(GeographyType, struct23_read, alloc);
    try Meta.expectEqualDeep(struct23, struct23_read);
    const union1_read = try Meta.unionRead(LogicalType, alloc, &r);
    defer Meta.deinit(LogicalType, union1_read, alloc);
    try Meta.expectEqualDeep(union1, union1_read);
    const struct24_read = try Meta.structRead(SchemaElement, alloc, &r);
    defer Meta.deinit(SchemaElement, struct24_read, alloc);
    try Meta.expectEqualDeep(struct24, struct24_read);
    const struct25_read = try Meta.structRead(DataPageHeader, alloc, &r);
    defer Meta.deinit(DataPageHeader, struct25_read, alloc);
    try Meta.expectEqualDeep(struct25, struct25_read);
    const struct26_read = try Meta.structRead(IndexPageHeader, alloc, &r);
    defer Meta.deinit(IndexPageHeader, struct26_read, alloc);
    try Meta.expectEqualDeep(struct26, struct26_read);
    const struct27_read = try Meta.structRead(DictionaryPageHeader, alloc, &r);
    defer Meta.deinit(DictionaryPageHeader, struct27_read, alloc);
    try Meta.expectEqualDeep(struct27, struct27_read);
    const struct28_read = try Meta.structRead(DataPageHeaderV2, alloc, &r);
    defer Meta.deinit(DataPageHeaderV2, struct28_read, alloc);
    try Meta.expectEqualDeep(struct28, struct28_read);
    const struct29_read = try Meta.structRead(SplitBlockAlgorithm, alloc, &r);
    defer Meta.deinit(SplitBlockAlgorithm, struct29_read, alloc);
    try Meta.expectEqualDeep(struct29, struct29_read);
    const union2_read = try Meta.unionRead(BloomFilterAlgorithm, alloc, &r);
    defer Meta.deinit(BloomFilterAlgorithm, union2_read, alloc);
    try Meta.expectEqualDeep(union2, union2_read);
    const struct30_read = try Meta.structRead(XxHash, alloc, &r);
    defer Meta.deinit(XxHash, struct30_read, alloc);
    try Meta.expectEqualDeep(struct30, struct30_read);
    const union3_read = try Meta.unionRead(BloomFilterHash, alloc, &r);
    defer Meta.deinit(BloomFilterHash, union3_read, alloc);
    try Meta.expectEqualDeep(union3, union3_read);
    const struct31_read = try Meta.structRead(Uncompressed, alloc, &r);
    defer Meta.deinit(Uncompressed, struct31_read, alloc);
    try Meta.expectEqualDeep(struct31, struct31_read);
    const union4_read = try Meta.unionRead(BloomFilterCompression, alloc, &r);
    defer Meta.deinit(BloomFilterCompression, union4_read, alloc);
    try Meta.expectEqualDeep(union4, union4_read);
    const struct32_read = try Meta.structRead(BloomFilterHeader, alloc, &r);
    defer Meta.deinit(BloomFilterHeader, struct32_read, alloc);
    try Meta.expectEqualDeep(struct32, struct32_read);
    const struct33_read = try Meta.structRead(PageHeader, alloc, &r);
    defer Meta.deinit(PageHeader, struct33_read, alloc);
    try Meta.expectEqualDeep(struct33, struct33_read);
    const struct34_read = try Meta.structRead(KeyValue, alloc, &r);
    defer Meta.deinit(KeyValue, struct34_read, alloc);
    try Meta.expectEqualDeep(struct34, struct34_read);
    const struct35_read = try Meta.structRead(SortingColumn, alloc, &r);
    defer Meta.deinit(SortingColumn, struct35_read, alloc);
    try Meta.expectEqualDeep(struct35, struct35_read);
    const struct36_read = try Meta.structRead(PageEncodingStats, alloc, &r);
    defer Meta.deinit(PageEncodingStats, struct36_read, alloc);
    try Meta.expectEqualDeep(struct36, struct36_read);
    const struct37_read = try Meta.structRead(ColumnMetaData, alloc, &r);
    defer Meta.deinit(ColumnMetaData, struct37_read, alloc);
    try Meta.expectEqualDeep(struct37, struct37_read);
    const struct38_read = try Meta.structRead(EncryptionWithFooterKey, alloc, &r);
    defer Meta.deinit(EncryptionWithFooterKey, struct38_read, alloc);
    try Meta.expectEqualDeep(struct38, struct38_read);
    const struct39_read = try Meta.structRead(EncryptionWithColumnKey, alloc, &r);
    defer Meta.deinit(EncryptionWithColumnKey, struct39_read, alloc);
    try Meta.expectEqualDeep(struct39, struct39_read);
    const union5_read = try Meta.unionRead(ColumnCryptoMetaData, alloc, &r);
    defer Meta.deinit(ColumnCryptoMetaData, union5_read, alloc);
    try Meta.expectEqualDeep(union5, union5_read);
    const struct40_read = try Meta.structRead(ColumnChunk, alloc, &r);
    defer Meta.deinit(ColumnChunk, struct40_read, alloc);
    try Meta.expectEqualDeep(struct40, struct40_read);
    const struct41_read = try Meta.structRead(RowGroup, alloc, &r);
    defer Meta.deinit(RowGroup, struct41_read, alloc);
    try Meta.expectEqualDeep(struct41, struct41_read);
    const struct42_read = try Meta.structRead(TypeDefinedOrder, alloc, &r);
    defer Meta.deinit(TypeDefinedOrder, struct42_read, alloc);
    try Meta.expectEqualDeep(struct42, struct42_read);
    const union6_read = try Meta.unionRead(ColumnOrder, alloc, &r);
    defer Meta.deinit(ColumnOrder, union6_read, alloc);
    try Meta.expectEqualDeep(union6, union6_read);
    const struct43_read = try Meta.structRead(PageLocation, alloc, &r);
    defer Meta.deinit(PageLocation, struct43_read, alloc);
    try Meta.expectEqualDeep(struct43, struct43_read);
    const struct44_read = try Meta.structRead(OffsetIndex, alloc, &r);
    defer Meta.deinit(OffsetIndex, struct44_read, alloc);
    try Meta.expectEqualDeep(struct44, struct44_read);
    const struct45_read = try Meta.structRead(ColumnIndex, alloc, &r);
    defer Meta.deinit(ColumnIndex, struct45_read, alloc);
    try Meta.expectEqualDeep(struct45, struct45_read);
    const struct46_read = try Meta.structRead(AesGcmV1, alloc, &r);
    defer Meta.deinit(AesGcmV1, struct46_read, alloc);
    try Meta.expectEqualDeep(struct46, struct46_read);
    const struct47_read = try Meta.structRead(AesGcmCtrV1, alloc, &r);
    defer Meta.deinit(AesGcmCtrV1, struct47_read, alloc);
    try Meta.expectEqualDeep(struct47, struct47_read);
    const union7_read = try Meta.unionRead(EncryptionAlgorithm, alloc, &r);
    defer Meta.deinit(EncryptionAlgorithm, union7_read, alloc);
    try Meta.expectEqualDeep(union7, union7_read);
    const struct48_read = try Meta.structRead(FileMetaData, alloc, &r);
    defer Meta.deinit(FileMetaData, struct48_read, alloc);
    try Meta.expectEqualDeep(struct48, struct48_read);
    const struct49_read = try Meta.structRead(FileCryptoMetaData, alloc, &r);
    defer Meta.deinit(FileCryptoMetaData, struct49_read, alloc);
    try Meta.expectEqualDeep(struct49, struct49_read);
}
